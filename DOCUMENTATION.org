#+title: Bachelor Thesis: Grammatical Evolution
#+description: Documentation for a grammatical evolution project with regular grammars.
#+author: Markus Fruhmann

* Grammatical Evolution
** Structure of regular grammars
This small section should evaluate regular grammars of varying complexity and evaluate different representations in Clojure.

*** A very simple example
Consider a regular grammar which should only produce words containing the letter ~a~. The only restriction is, that the word has to contain at least one 'a'.
Sample words could look like this: ~aaaaaa~, ~a~, ~aa~ etc.

The following rules could represent this regular grammar:

V_{T} = {_a_}
V_{N} = {S, A}

S = A
A = _a_ A
A = \epsilon

How can we now represent this rules as a tree-like structure? If we chose a very simplistic approach, we could simply nest rules if they reference each other like this:
#+begin_src clojure
(S
  (A "a"
     (A "\epsilon")))
#+end_src

For a different approach, let's analyse the textual description of this grammar again: /Words that contain ~a~ n times, but at least once/. If we wanted to specify this rule like a regular expression, we could simply write ~a+~ to get at least one ~a~. If we apply this to our ruleset, it could look like this:

V_{N} = {_a_}
V_{T} = {S, A}

S = A
A = _a_ +

By writing the grammar like this, we can express the same rules as before, but without the need of an additional rule for \epsilon.
The tree in our code would look like this:
#+begin_src clojure
(S
  (A "a" "+"))
#+end_src

*** Circular rules
Let's look at a more complex ruleset. This time, we want to create words that alternate between ~a~ and ~b~. Some example words could look like this: ~aba~, ~ababab~, ~ab~ etc.

Following rules could now represent our grammar:

V_{N} = {_a_, _b_}
V_{T} = {S, A, B}

S = A
A = aB
A = \epsilon
B = bA
B = \epsilon

We are not able to simplify these rules by using regular expression syntax. Hence, our tree could look like this:
#+begin_src clojure
(S
  (A "a"
     (B "b"
        (A "\epsilon"))))
#+end_src

We now have the problem, that we are unable to express =B = \epsilon= this way, since =B= is only referenced once, but =A= is referenced twice.
We could enhance our syntax with regular expression symbols, in order to convey different rules.

#+begin_src clojure
(S
  (A "a" "*" "A"))
#+end_src

This would be equivalent to following ruleset:

V_{T} = {_a_}
V_{N} = {S, A}

S = A
A = _a_ A
A = \epsilon

Similarly this:

#+begin_src clojure
(S
  (A "a" "+" "A"))
#+end_src

would result in:

V_{T} = {_a_}
V_{N} = {S, A}

S = A
A = _a_ A
A = _a_

If we now apply this to our more complex example from the beginning, following tree might be created:
#+begin_src clojure
(S
  (A "a" "*"
     (B "b" "*"
        (A "\epsilon"))))
#+end_src

Upon evaluation of this tree, we can remove redundant modifiers.
#+begin_src clojure
(S
  (A "a"
     (B "b" "*"
        (A "\epsilon"))))
#+end_src

For each inserted terminal symbol, either ~*~, ~+~ or no modifier are added. This creates a more equal way to create rules,

*** Exit conditions
If we reconsider the example above, the grammar also allows an empty word \epsilon as valid. Following grammar defines the case, when at least one pair ~ab~ should be produced.

V_{N} = {_a_, _b_}
V_{T} = {S, A, B, C}

S = A
A = aB
A = aC
B = bA
C = b

We could represent those rules in a tree like this:
#+begin_src clojure
(S
  (A "a"
     (B "b"
        (A "a"
           (C "b")))))
#+end_src

We now can decode each level of the tree into a rule, whilst also taking nested rules into account. This notation should be sufficient to depict any regular grammar.

Following rules are applied when creating a new rule tree:
1. All /terminal symbols/ are treated as variables.
2. All /non-terminal symbols/ are treated as functions.
3. A terminal symbol can get a /modifier/ ~*~ or ~+~.

** Generating an initial population
*** Generating regular grammar trees
A very simplistic approach to generating trees would be to restrict generation by inherent principles of regular grammars. Therefore, for each rule, one terminal symbol with a modifier will be selected. Then, a non-terminal symbol might be selected and a new rule for this non-terminal symbol will be created.

We start with the rule S.
#+begin_src clojure
(S)
#+end_src
S will point to our first rule, so another rule will be immediatly created.
#+begin_src clojure
;; select from V_N = {A, B, C, 0}
;; 0 marks the possibility that no additional rule might be created as well
(S
  (A))
#+end_src
Rule A needs a terminal symbol, to be valid in terms of regular grammars.
#+begin_src clojure
;; select from V_T = {"a", "b", "\epsilon"}
(S
  (A "a"))
#+end_src
An optional modifier can be selected as well.
#+begin_src clojure
;; select from V_mod = {"", "*", "+"}
(S
  (A "a" "+"))
#+end_src
We now randomly decide, if we want to add another rule.
#+begin_src clojure
;; select from V_N = {A, B, C, 0}
(S
  (A "a" "+"
     (C)))
#+end_src
We can now complete this rule.
#+begin_src clojure
(S
  (A "a" "+"
     (C "b" "" 0)))
#+end_src
In this case, 0 was selected as the next rule, so further rule will be created. Following final ruleset is being created:

V_{T} = {_a_, _b_}
V_{N} = {S, A, C}
V_{mod} = {"", +}

S \rightarrow A
A \rightarrow _a_ C
A \rightarrow _a_
C \rightarrow _b_

*** grow
*** full
*** ramped half-and-half
